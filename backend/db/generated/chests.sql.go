// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChest = `-- name: CreateChest :one
INSERT INTO chests (type, description, price)
VALUES ($1, $2, $3)
RETURNING id, type, description, price, created_at, updated_at
`

type CreateChestParams struct {
	Type        ChestType
	Description string
	Price       int32
}

// Chest Operations
func (q *Queries) CreateChest(ctx context.Context, arg CreateChestParams) (Chest, error) {
	row := q.db.QueryRow(ctx, createChest, arg.Type, arg.Description, arg.Price)
	var i Chest
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChestItem = `-- name: CreateChestItem :one
INSERT INTO chest_items (image_url, title, rarity, price)
VALUES ($1, $2, $3, $4)
RETURNING id, image_url, title, rarity, price, created_at, updated_at
`

type CreateChestItemParams struct {
	ImageUrl pgtype.Text
	Title    string
	Rarity   ItemType
	Price    pgtype.Int4
}

// Chest Item Operations
func (q *Queries) CreateChestItem(ctx context.Context, arg CreateChestItemParams) (ChestItem, error) {
	row := q.db.QueryRow(ctx, createChestItem,
		arg.ImageUrl,
		arg.Title,
		arg.Rarity,
		arg.Price,
	)
	var i ChestItem
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.Title,
		&i.Rarity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChestItemDropRate = `-- name: CreateChestItemDropRate :one
INSERT INTO chest_item_drop_rates (item_id, chest_id, drop_rate)
VALUES ($1, $2, $3)
RETURNING id, item_id, chest_id, drop_rate, created_at, updated_at
`

type CreateChestItemDropRateParams struct {
	ItemID   pgtype.UUID
	ChestID  pgtype.UUID
	DropRate float64
}

// Chest Item Drop Rate Operations
func (q *Queries) CreateChestItemDropRate(ctx context.Context, arg CreateChestItemDropRateParams) (ChestItemDropRate, error) {
	row := q.db.QueryRow(ctx, createChestItemDropRate, arg.ItemID, arg.ChestID, arg.DropRate)
	var i ChestItemDropRate
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ChestID,
		&i.DropRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserChest = `-- name: CreateUserChest :one
INSERT INTO user_chests (user_id, chest_id, quantity_owned)
VALUES ($1, $2, $3)
RETURNING id, user_id, chest_id, quantity_owned, created_at, updated_at
`

type CreateUserChestParams struct {
	UserID        pgtype.UUID
	ChestID       pgtype.UUID
	QuantityOwned pgtype.Int4
}

// User Chest Operations
func (q *Queries) CreateUserChest(ctx context.Context, arg CreateUserChestParams) (UserChest, error) {
	row := q.db.QueryRow(ctx, createUserChest, arg.UserID, arg.ChestID, arg.QuantityOwned)
	var i UserChest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChestID,
		&i.QuantityOwned,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserItem = `-- name: CreateUserItem :one
INSERT INTO user_items (user_id, item_id, status)
VALUES ($1, $2, $3)
RETURNING id, user_id, item_id, status, created_at, updated_at
`

type CreateUserItemParams struct {
	UserID pgtype.UUID
	ItemID pgtype.UUID
	Status NullItemStatus
}

// User Item Operations
func (q *Queries) CreateUserItem(ctx context.Context, arg CreateUserItemParams) (UserItem, error) {
	row := q.db.QueryRow(ctx, createUserItem, arg.UserID, arg.ItemID, arg.Status)
	var i UserItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteChestById = `-- name: DeleteChestById :exec
DELETE FROM chests WHERE id = $1
`

func (q *Queries) DeleteChestById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChestById, id)
	return err
}

const deleteChestItemById = `-- name: DeleteChestItemById :exec
DELETE FROM chest_items WHERE id = $1
`

func (q *Queries) DeleteChestItemById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChestItemById, id)
	return err
}

const deleteDropRate = `-- name: DeleteDropRate :exec
DELETE FROM chest_item_drop_rates WHERE id = $1
`

func (q *Queries) DeleteDropRate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDropRate, id)
	return err
}

const deleteUserChest = `-- name: DeleteUserChest :exec
DELETE FROM user_chests WHERE user_id = $1 AND chest_id = $2
`

type DeleteUserChestParams struct {
	UserID  pgtype.UUID
	ChestID pgtype.UUID
}

func (q *Queries) DeleteUserChest(ctx context.Context, arg DeleteUserChestParams) error {
	_, err := q.db.Exec(ctx, deleteUserChest, arg.UserID, arg.ChestID)
	return err
}

const deleteUserItem = `-- name: DeleteUserItem :exec
DELETE FROM user_items WHERE id = $1
`

func (q *Queries) DeleteUserItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserItem, id)
	return err
}

const getAllChestItems = `-- name: GetAllChestItems :many
SELECT id, image_url, title, rarity, price, created_at, updated_at FROM chest_items ORDER BY created_at DESC
`

func (q *Queries) GetAllChestItems(ctx context.Context) ([]ChestItem, error) {
	rows, err := q.db.Query(ctx, getAllChestItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChestItem
	for rows.Next() {
		var i ChestItem
		if err := rows.Scan(
			&i.ID,
			&i.ImageUrl,
			&i.Title,
			&i.Rarity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllChests = `-- name: GetAllChests :many
SELECT id, type, description, price, created_at, updated_at FROM chests ORDER BY price ASC
`

func (q *Queries) GetAllChests(ctx context.Context) ([]Chest, error) {
	rows, err := q.db.Query(ctx, getAllChests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chest
	for rows.Next() {
		var i Chest
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChestById = `-- name: GetChestById :one
SELECT id, type, description, price, created_at, updated_at FROM chests WHERE id = $1
`

func (q *Queries) GetChestById(ctx context.Context, id pgtype.UUID) (Chest, error) {
	row := q.db.QueryRow(ctx, getChestById, id)
	var i Chest
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChestItemById = `-- name: GetChestItemById :one
SELECT id, image_url, title, rarity, price, created_at, updated_at FROM chest_items WHERE id = $1
`

func (q *Queries) GetChestItemById(ctx context.Context, id pgtype.UUID) (ChestItem, error) {
	row := q.db.QueryRow(ctx, getChestItemById, id)
	var i ChestItem
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.Title,
		&i.Rarity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDropRatesByChestId = `-- name: GetDropRatesByChestId :many
SELECT id, item_id, chest_id, drop_rate, created_at, updated_at FROM chest_item_drop_rates WHERE chest_id = $1
`

func (q *Queries) GetDropRatesByChestId(ctx context.Context, chestID pgtype.UUID) ([]ChestItemDropRate, error) {
	rows, err := q.db.Query(ctx, getDropRatesByChestId, chestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChestItemDropRate
	for rows.Next() {
		var i ChestItemDropRate
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.ChestID,
			&i.DropRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDropRatesByItemId = `-- name: GetDropRatesByItemId :many
SELECT id, item_id, chest_id, drop_rate, created_at, updated_at FROM chest_item_drop_rates WHERE item_id = $1
`

func (q *Queries) GetDropRatesByItemId(ctx context.Context, itemID pgtype.UUID) ([]ChestItemDropRate, error) {
	rows, err := q.db.Query(ctx, getDropRatesByItemId, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChestItemDropRate
	for rows.Next() {
		var i ChestItemDropRate
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.ChestID,
			&i.DropRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChestByUserIdAndChestId = `-- name: GetUserChestByUserIdAndChestId :one
SELECT id, user_id, chest_id, quantity_owned, created_at, updated_at FROM user_chests WHERE user_id = $1 AND chest_id = $2
`

type GetUserChestByUserIdAndChestIdParams struct {
	UserID  pgtype.UUID
	ChestID pgtype.UUID
}

func (q *Queries) GetUserChestByUserIdAndChestId(ctx context.Context, arg GetUserChestByUserIdAndChestIdParams) (UserChest, error) {
	row := q.db.QueryRow(ctx, getUserChestByUserIdAndChestId, arg.UserID, arg.ChestID)
	var i UserChest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChestID,
		&i.QuantityOwned,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserChestsByUserId = `-- name: GetUserChestsByUserId :many
SELECT id, user_id, chest_id, quantity_owned, created_at, updated_at FROM user_chests WHERE user_id = $1
`

func (q *Queries) GetUserChestsByUserId(ctx context.Context, userID pgtype.UUID) ([]UserChest, error) {
	rows, err := q.db.Query(ctx, getUserChestsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserChest
	for rows.Next() {
		var i UserChest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ChestID,
			&i.QuantityOwned,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserItemById = `-- name: GetUserItemById :one
SELECT id, user_id, item_id, status, created_at, updated_at FROM user_items WHERE id = $1
`

func (q *Queries) GetUserItemById(ctx context.Context, id pgtype.UUID) (UserItem, error) {
	row := q.db.QueryRow(ctx, getUserItemById, id)
	var i UserItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserItemsByUserId = `-- name: GetUserItemsByUserId :many
SELECT id, user_id, item_id, status, created_at, updated_at FROM user_items WHERE user_id = $1
`

func (q *Queries) GetUserItemsByUserId(ctx context.Context, userID pgtype.UUID) ([]UserItem, error) {
	rows, err := q.db.Query(ctx, getUserItemsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserItem
	for rows.Next() {
		var i UserItem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChestById = `-- name: UpdateChestById :one
UPDATE chests
SET type = coalesce($1, type),
    description = coalesce($2, description),
    price = coalesce($3, price)
WHERE id = $4
RETURNING id, type, description, price, created_at, updated_at
`

type UpdateChestByIdParams struct {
	Type        NullChestType
	Description pgtype.Text
	Price       pgtype.Int4
	ID          pgtype.UUID
}

func (q *Queries) UpdateChestById(ctx context.Context, arg UpdateChestByIdParams) (Chest, error) {
	row := q.db.QueryRow(ctx, updateChestById,
		arg.Type,
		arg.Description,
		arg.Price,
		arg.ID,
	)
	var i Chest
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChestItemById = `-- name: UpdateChestItemById :one
UPDATE chest_items
SET image_url = coalesce($1, image_url),
    title = coalesce($2, title),
    rarity = coalesce($3, rarity),
    price = coalesce($4, price)
WHERE id = $5
RETURNING id, image_url, title, rarity, price, created_at, updated_at
`

type UpdateChestItemByIdParams struct {
	ImageUrl pgtype.Text
	Title    pgtype.Text
	Rarity   NullItemType
	Price    pgtype.Int4
	ID       pgtype.UUID
}

func (q *Queries) UpdateChestItemById(ctx context.Context, arg UpdateChestItemByIdParams) (ChestItem, error) {
	row := q.db.QueryRow(ctx, updateChestItemById,
		arg.ImageUrl,
		arg.Title,
		arg.Rarity,
		arg.Price,
		arg.ID,
	)
	var i ChestItem
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.Title,
		&i.Rarity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDropRate = `-- name: UpdateDropRate :one
UPDATE chest_item_drop_rates
SET drop_rate = $2
WHERE id = $1
RETURNING id, item_id, chest_id, drop_rate, created_at, updated_at
`

type UpdateDropRateParams struct {
	ID       pgtype.UUID
	DropRate float64
}

func (q *Queries) UpdateDropRate(ctx context.Context, arg UpdateDropRateParams) (ChestItemDropRate, error) {
	row := q.db.QueryRow(ctx, updateDropRate, arg.ID, arg.DropRate)
	var i ChestItemDropRate
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ChestID,
		&i.DropRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserChestQuantity = `-- name: UpdateUserChestQuantity :one
UPDATE user_chests
SET quantity_owned = $2
WHERE user_id = $1 AND chest_id = $3
RETURNING id, user_id, chest_id, quantity_owned, created_at, updated_at
`

type UpdateUserChestQuantityParams struct {
	UserID        pgtype.UUID
	QuantityOwned pgtype.Int4
	ChestID       pgtype.UUID
}

func (q *Queries) UpdateUserChestQuantity(ctx context.Context, arg UpdateUserChestQuantityParams) (UserChest, error) {
	row := q.db.QueryRow(ctx, updateUserChestQuantity, arg.UserID, arg.QuantityOwned, arg.ChestID)
	var i UserChest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChestID,
		&i.QuantityOwned,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserItemStatus = `-- name: UpdateUserItemStatus :one
UPDATE user_items
SET status = $2
WHERE id = $1
RETURNING id, user_id, item_id, status, created_at, updated_at
`

type UpdateUserItemStatusParams struct {
	ID     pgtype.UUID
	Status NullItemStatus
}

func (q *Queries) UpdateUserItemStatus(ctx context.Context, arg UpdateUserItemStatusParams) (UserItem, error) {
	row := q.db.QueryRow(ctx, updateUserItemStatus, arg.ID, arg.Status)
	var i UserItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
