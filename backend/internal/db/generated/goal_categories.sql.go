// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: goal_categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGoalCategory = `-- name: CreateGoalCategory :one
INSERT INTO goal_categories (title, xp_per_goal, user_id)
VALUES ($1, $2, $3)
RETURNING id, title, xp_per_goal, user_id, created_at, updated_at
`

type CreateGoalCategoryParams struct {
	Title     string
	XpPerGoal int32
	UserID    pgtype.UUID
}

func (q *Queries) CreateGoalCategory(ctx context.Context, arg CreateGoalCategoryParams) (GoalCategory, error) {
	row := q.db.QueryRow(ctx, createGoalCategory, arg.Title, arg.XpPerGoal, arg.UserID)
	var i GoalCategory
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.XpPerGoal,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGoalCategoryById = `-- name: DeleteGoalCategoryById :execrows
DELETE FROM goal_categories WHERE id = $1 AND user_id = $2
`

type DeleteGoalCategoryByIdParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeleteGoalCategoryById(ctx context.Context, arg DeleteGoalCategoryByIdParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGoalCategoryById, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getGoalCategoriesByUserId = `-- name: GetGoalCategoriesByUserId :many
SELECT id, title, xp_per_goal, user_id, created_at, updated_at FROM goal_categories WHERE user_id = $1 ORDER BY created_at
`

func (q *Queries) GetGoalCategoriesByUserId(ctx context.Context, userID pgtype.UUID) ([]GoalCategory, error) {
	rows, err := q.db.Query(ctx, getGoalCategoriesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GoalCategory
	for rows.Next() {
		var i GoalCategory
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.XpPerGoal,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoalCategoriesWithGoalsByUserId = `-- name: GetGoalCategoriesWithGoalsByUserId :many
SELECT
    gc.id, gc.title, gc.xp_per_goal, gc.user_id, gc.created_at, gc.updated_at,
    g.id as goal_id, g.title as goal_title, g.description, g.status,
    g.created_at as goal_created_at, g.updated_at as goal_updated_at
FROM goal_categories gc
LEFT JOIN goals g ON gc.id = g.category_id
WHERE gc.user_id = $1
ORDER BY gc.created_at, g.created_at DESC
`

type GetGoalCategoriesWithGoalsByUserIdRow struct {
	ID            pgtype.UUID
	Title         string
	XpPerGoal     int32
	UserID        pgtype.UUID
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	GoalID        pgtype.UUID
	GoalTitle     pgtype.Text
	Description   pgtype.Text
	Status        NullGoalStatus
	GoalCreatedAt pgtype.Timestamp
	GoalUpdatedAt pgtype.Timestamp
}

func (q *Queries) GetGoalCategoriesWithGoalsByUserId(ctx context.Context, userID pgtype.UUID) ([]GetGoalCategoriesWithGoalsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getGoalCategoriesWithGoalsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGoalCategoriesWithGoalsByUserIdRow
	for rows.Next() {
		var i GetGoalCategoriesWithGoalsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.XpPerGoal,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GoalID,
			&i.GoalTitle,
			&i.Description,
			&i.Status,
			&i.GoalCreatedAt,
			&i.GoalUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoalCategoryById = `-- name: GetGoalCategoryById :one
SELECT id, title, xp_per_goal, user_id, created_at, updated_at FROM goal_categories WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetGoalCategoryByIdParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) GetGoalCategoryById(ctx context.Context, arg GetGoalCategoryByIdParams) (GoalCategory, error) {
	row := q.db.QueryRow(ctx, getGoalCategoryById, arg.ID, arg.UserID)
	var i GoalCategory
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.XpPerGoal,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGoalCategoryWithGoalsById = `-- name: GetGoalCategoryWithGoalsById :many
SELECT
    gc.id, gc.title, gc.xp_per_goal, gc.user_id, gc.created_at, gc.updated_at,
    g.id as goal_id, g.title as goal_title, g.description, g.status,
    g.created_at as goal_created_at, g.updated_at as goal_updated_at
FROM goal_categories gc
LEFT JOIN goals g ON gc.id = g.category_id
WHERE gc.id = $1 AND gc.user_id = $2
ORDER BY g.created_at DESC
`

type GetGoalCategoryWithGoalsByIdParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

type GetGoalCategoryWithGoalsByIdRow struct {
	ID            pgtype.UUID
	Title         string
	XpPerGoal     int32
	UserID        pgtype.UUID
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	GoalID        pgtype.UUID
	GoalTitle     pgtype.Text
	Description   pgtype.Text
	Status        NullGoalStatus
	GoalCreatedAt pgtype.Timestamp
	GoalUpdatedAt pgtype.Timestamp
}

func (q *Queries) GetGoalCategoryWithGoalsById(ctx context.Context, arg GetGoalCategoryWithGoalsByIdParams) ([]GetGoalCategoryWithGoalsByIdRow, error) {
	rows, err := q.db.Query(ctx, getGoalCategoryWithGoalsById, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGoalCategoryWithGoalsByIdRow
	for rows.Next() {
		var i GetGoalCategoryWithGoalsByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.XpPerGoal,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GoalID,
			&i.GoalTitle,
			&i.Description,
			&i.Status,
			&i.GoalCreatedAt,
			&i.GoalUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGoalCategoryById = `-- name: UpdateGoalCategoryById :one
UPDATE goal_categories
SET title = coalesce($1, title),
    xp_per_goal = coalesce($2, xp_per_goal)
WHERE id = $3 AND user_id = $4
RETURNING id, title, xp_per_goal, user_id, created_at, updated_at
`

type UpdateGoalCategoryByIdParams struct {
	Title     pgtype.Text
	XpPerGoal pgtype.Int4
	ID        pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) UpdateGoalCategoryById(ctx context.Context, arg UpdateGoalCategoryByIdParams) (GoalCategory, error) {
	row := q.db.QueryRow(ctx, updateGoalCategoryById,
		arg.Title,
		arg.XpPerGoal,
		arg.ID,
		arg.UserID,
	)
	var i GoalCategory
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.XpPerGoal,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
